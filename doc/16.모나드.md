# 모나드

> **이 글은 [Swift 프로그래밍](http://m.hanbit.co.kr/store/books/book_view.html?p_code=B9421379018)책을 읽고 요약한 내용입니다.**

'탕'함수형 프로그래밍에서의 모나드는 순서가 있는 연산을 처리할 대 자주 활용하는 디자인패턴입니다.

프로그래밍에서 모나드가 갖춰야 하는 조건은 다음과 같습니다.

* 타입을 인자로 받는 타입(특정 타입의 값을 포장)
* 특정 타입의 값을 포장한 것을 반환하는 함수(메서드)가 존재
* 포장된 값을 변환하여 같은 형태로 포장하는 함수(메서드)가 존재

'타입을 인자로 받는다' 는 표현은 제네릭이라는 기능을 통해 구현할 수 있습니다.
설명을 위해 옵셔널을 활용해보겠습니다.

**모나드를 이해하는 출발점은 값을 어딘가에 포장하는 개념을 이해하는 것에서 출발합니다.**
스위프트에서 모나드를 사용한 예 중에 하나가 바로 옵셔널 입니다.
옵셔널은 값이 있을지 없을지 모르는 상태를 포장하는 것입니다.

`함수객체`와 `모나드`는 특정 기능이 아닌 디자인 패턴 혹은 자료구조라고 할 수 있습니다.
모나드를 이해하기에 앞서 이해해야 할 몇가지 개념이 있습니다. 옵셔널을 하나하나 파헤쳐 보면서 순서에 따라 조금씩 알아보겠습니다.

## 컨텍스트

**컨텍스트는 콘텐츠를 담은 그 무엇인가** 를 뜻합니다.
즉, 물컵에 물이 담겨있으면 물은 콘텐츠 이고, 물컵은 컨텍스트라고 볼 수 있습니다.

컨텍스트에 대해 알아보기 전ㄴ에 옵셔널을 다시 한번 되새겨볼 필요가 있습니다.

**Optional**

```swift
enum Optional<Wrapped>: ExpressibleByNilLiteral{
  case none
  case some(Wrapped)
  public init(_ some: Wrapped)
  // ...
}
```

옵셔널은 열거형(enum)으로 구현되어 있어서 ( enum Optional\<Wrapped> )
열거형 case의 연관 값을 통해 ( case some(Wrapped) )
인스턴스 안에 연관 값을 갖는 형태입니다.

옵셔널에 값이 없다면 열거형의 none 으로, 값이 있따면 열거형의 some(Wrapped)로 값을 지니게 됩니다.
옵셔널 값을 추출한ㄴ다는 것은 열거형의 인스턴스 내부의 some(Wrapped)의 연관 값을 꺼내오는 것과 같습니다.

2라는 숫자를 옵셔널로 둘러싸면, 컨텍스트 안에 2라는 콘텐츠가 들어가는 모양새입니다.
그리고 **'컨텍스트는 2라는 값을 가지고 있다.'**라고 말할 수 있습니다.
만약 값이 없는 옵셔널 상태라면 **'컨텍스트는 존재하지만 내부에 값이 없다'** 라고 할 수 있습니다.

이처럼 값(콘텐츠)과 컨텍스트의 관계를 이해하는 것이 이번 글의 출발점입니다.

앞서 설명했던 모나드가 갖춰야할 조건을 떠올려보면

* 첫번째: Optional은 Wrapped 타입을 인자로 받는 (제네릭)타입 입니다.
* 두번째: Optional 타입은 `Optional\<Int>.init(2)` 처럼 다른 타입(Int)의 값을 갖는 상태의 컨텍스트를 생성할 수 있습니다.

현재까지 설명한 바로는 첫번째, 두번째 조건은 만족하고 있습니다. 세번째는 이제 슬슬 알아보도록 하겠습니다.

```swift
func addThree(_ num: Int) -> Int{
    return num + 3
}

addThree(2) // 5
addThree(Optional(2)) // Error!
```

위의 `addThree` 함수에 파라미터로 2를 넘기면 정상적으로 함수가 동작합니다. `addThree`  함수는 파라미터로 일반 Int 타입의 값을 받기 때문입니다.

그러나 옵셔널을 전달인자로 사용하려고 한다면 오류가 발생합니다. 순수한 값이 아닌 **옵셔널이라는 컨텍스트로 둘러싸여 전달**되었기 때문입니다.



## 함수객체

`map` 은 컨테이너(**컨테이너는 다른 타입의 값을 담을 수 있으므로 컨텍스트의 역할을 수행할 수 있음.**)의 값을 변형시킬 수 있는 고차함수 입니다.
그리고 옵션널은 컨테이너와 값을 갖기 때문에 맵 함수를 사용할 수 있습니다.

```swift
Optional(2).map(addThree) // 5

//따로 함수가 없어도 클로저를 사용할 수도 있다.
var value: Int? = 2
value.map({ $0 + 3 }) // Opational(5)
value = nil
value.map({ $0 + 3 }) // nil(== Optional<Int>.none)
```

**map을 언급한 이유**

**함수객체란 맵을 적용할 수 있는 컨테이너 타입**
즉, 우리가 앞서 맵을 사용해보았던 Array, Dictionary, Set 등등 스위프트의 많은 컬렉션 타입이 함수객체입니다.

> 함수 객체란
>
> ```swift
> var n: Int? = 2
> print(n+3) // Error
> ```
>
> 위의 코드는 에러가 발생하는 코드.
> -> 그래서 이것(`n`)을 꺼내는 작업이 필요하다.
> 그 작업이 바로 `map`
>
> ```swift
> var n: Int? = 2
> print(n.map({ $0 + 3 })) //Opational(5)
> ```
>
> `map` 이라는게 요소 하나하나 보면서 값이 있나 확인ㄴ 후 있다면 해당 요소를 꺼낸다.(`$0`)
> 같은 타입이라면 3을 더한다.(`+3`)
> Opational(5)가 된 이유는 `map` 은 다시 컨테이너에 넣어서 돌려주기 때문
> 여기서 함수객체는 Optional 변수인 n이다.

**map이 어떻게 동작하는가**

1. map이 함수를 인자로 받음 ( ex) addThree(_:) )
2. 함수객체에 map이 전달받은 함수를 적용 ( ex) Opational(2) )
3. 새로운 함수객체를 반환 ( ex) Optional(5) )

위의 동작을 코드로 구현하면 아래와 같습니다.

```swift
///옵셔널의 map 구현
extension Optional{
    func map<T>(f: (Wrapped) -> T) -> T? {
        switch self {
        case .some(let x):
            return f(x) // x를 (Wrapped) -> T 함수의 Wrapped 타입 파라미터 값으로 전달한다.
          							// 그리고 T 형태의 값으로 리턴한다.
        case .none:
            return .none
        }
    }
}
```

값이 있다면 전달받은 함수에 자신의 값을 적용한 결과값을 다시 컨텍스트에 넣어 반환하고, 그렇지 않다면 함수를 실행하지 않고 빈 컨텍스트를 반환합니다.

예를 들어 ( **addThree 함수는 +3 만 수행합니다.**)

> **밑의 옵셔널의 map구혀 동작설명은 제가 임의로 추측해서 적은 글입니다. 피드백 부탁드립니다.**

```swift
func addThree(_ num: Int) -> Int{
    return num + 3
}
```

* Optional(2).map(addThree)

  여기서
  `addThree` 는 `f` 가 됩니다.
  `T` 는 `Int`  가 됩니다.

  `x` 는 `2` 가 됩니다.
  `Wrapped` 는 `Optional` 입니다.

  * 1. 컨텍스트로 부터 값 추출
    2. 전달받은 함수 적용
    3. 결과값을 다시 컨텍스트에 담아 반환

* Optional.none.map(addThree)

  컨텍스트에 값이 없다면 빈컨텍스트로 다시 반환합니다.



## 모나드와 flatMap

함수객체 중에서 **자신의 컨텍스트와 같은 컨텍스트의 형태로 맵핑할 수 있는 함수객체**를 닫힌함수객체 라고 합니다.
모나드는 닫힌 함수객체 입니다.

함수객체는 포장된 값에 함수를 적용할 수 있었습니다.
모나드도 **컨텍스트에 포장된 값을 처리하여 포장된 값을 컨텍스트에 다시 반환하는 함수(map)** 를 적용할 수 있습니다.
이 **매핑의 결과가 함수객체와 같은 컨텍스트를 반환하는 함수객체**를 모나드라고 할 수 있으며,
이런 매핑을 수행하도록 `flatMap` 이라는 메서드를 사용합니다.

## Reference

* Monad: https://tech.kakao.com/2016/03/03/monad-programming-with-scala-future/
* flatMap vs compactMap: https://zeddios.tistory.com/448